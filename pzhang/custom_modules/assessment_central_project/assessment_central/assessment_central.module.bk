<?php
// $Id$
define('NHPID_AUTO_WORKFLOW_MSG', 'Changed based on the NHPID dependency rule automatically by Drupal');

$path = drupal_get_path('module', 'nhpid');
//drupal_add_css($path .'/nhpid.css');
//drupal_add_js($path .'/nhpid.js');

###// Detects user's browser
$javascript_browser_name = 'if (navigator.appName.indexOf("Internet Explorer") != -1) {alert("I find that your browser is Microsoft Insternet Explorer, which may not be compatible to the settings of some Drupal themes. If you find that the content cannot be properly displayed, please change your theme or your browser, such as Chrome or Firefox.")};  ';
global $user;
if ($user-> name and $user-> login >= $user -> timestamp) {
  drupal_add_js($javascript_browser_name, 'inline');
  //drupal_set_message($javascript_browser_name);
}
function nhpid_perm() {
    return array('administer assessment central', 'access assessment central content');
} // function nhpid_perm()

function nhpid_menu_alter(&$items){
  //drupal_set_message(nhpid_api_dump(&$items, 'red', TRUE));
  $items['node/%node/edit']['access callback']='_nhpid_node_access_callback';
  $items['node/%node/edit']['access arguments'] = array(1,'edit');
  /* not working
  $items['node/%node/revisions']['access callback']='_nhpid_node_access_callback';
  $items['node/%node/revisions']['access arguments'] = array(1,'revisions');
  $items['node/%node/revisions/%/delete']['access callback']='_nhpid_node_access_callback';
  $items['node/%node/revisions/%/delete']['access arguments'] = array(1,'revisions');
  $items['node/%node/revisions/%/revert']['access callback']='_nhpid_node_access_callback';
  $items['node/%node/revisions/%/revert']['access arguments'] = array(1,'revisions');
  */
  $items['node/%node/children']['access callback']='_nhpid_node_access_callback';
  $items['node/%node/children']['access arguments'] = array(1,'children');
  //drupal_set_message(nhpid_api_dump(&$items, 'green', TRUE));

}
function nhpid_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  $node_type = $form['#node']? $form['#node']->type : '';
  $form_id = $form['form_id']['#id'];
  $pattern = '/edit\-(.+)\-node\-form/';
  //drupal_set_message(nhpid_api_dump($form, 'green', TRUE));
  if (nhpid_is_a_data_node_type($node_type) and $form_id == str_replace('_', '-', "edit-$node_type-node-form")) {
    // *** Add javascript alert to remind user to update workflow state ****
    $form['buttons']['submit']['#attributes'] = array('onclick' => 'alert("I bet you did not forget to update workflow state.")');
    //drupal_set_message(nhpid_api_dump($form['buttons'], 'green', TRUE));
    ### remove 'delete button' if user does not have permission to to it.
    ### rationale: we can do it by change persimmion settings. Howver, if the permussion 'administer nodes' is disabled. Drupal is slowed done a lot. If web speed is fast enough and delete permission is set based node types, this form alternation is not needed.
    ### Only rood admin and roles administrator and data coordinator can delete content.
    $allowed_roles = array('administrator');
    //drupal_set_message(nhpid_api_dump($user, 'red', TRUE));
    //drupal_set_message(nhpid_api_dump($user -> roles, 'red', TRUE));
    if (!(array_intersect($user -> roles, $allowed_roles) or $user -> uid == 1)) {
      unset($form['buttons']['delete']); 
    }
    /** not working yet. todo: find 
    ## blocks edting nhpid menu struture nodes by users other than admin
    $nhpid_menu_node_types = array("nhpid_data_entry", "list_records", "nhpid_data_form","nhpid_data_form_group", "fields_house");
    
    if (in_array($node_type, $nhpid_menu_node_types) and $user -> uid != 1) {
      unset($form['buttons']['edit']);
    }
    */
    //*** Add #after_build callback 
    if (!isset($form['#after_build'])) {
      $form['#after_build'] = array();
    }
    if (!(in_array('nhpid_node_form_after_build', $form['#after_build']))) {
      array_unshift($form['#after_build'], 'nhpid_node_form_after_build');
      //$form['#after_build'][] =  'nhpid_node_form_after_build';
    }
  }
  //drupal_set_message(nhpid_api_dump($form, 'green', TRUE));
}


/**
* "After build" callback for node forms. Register the fields to alter.
*/
function nhpid_node_form_after_build($form_element, &$form_state) {

  $node_type = $form_element['#node'] -> type;
  $fields = get_node_type_field_name_title_mapping($node_type);
  //drupal_set_message(nhpid_api_dump($fields, 'green', TRUE));
  foreach ($fields as $key => $value) {
    nhpid_node_form_element_alter_register($form_element, $key, $node_type);
    //nhpid_node_form_element_description_alter($form_element, $key, $node_type);
  }
  //drupal_set_message(nhpid_api_dump($form_element, 'green', TRUE));
  return $form_element;
}

/**
* Implementation of hook_node_form_element_alter().
*/
function nhpid_node_form_element_alter($name, &$element,  $node_type) {
  /*** set rquired fields ***
   * 'required' attribute is set globally by drupal. NHPID shared fields can be both required or non-required with different node types.
   * this function sets the required attribute os node form dynamically based on variables 'nhpid_NODE TYPE_FIELD NAME_is_required', 
   * which are manged by NHPID MAN     
   */     
   
  $variable_name = "nhpid_" . $node_type . '_' . $name . "_is_required";
  $required = nhpid_is_nhpid_data_field_required($node_type, $name);
  foreach (element_children($element) as $key) {
    if (isset($element[$key]) && $element[$key]) {
      
      //*** Recurse through all children elements.
      nhpid_node_form_element_alter($name, $element[$key],  $node_type);
    }
  }
  
  $pattern = '/field_(?!flexi).+_dependency/';
  if ((isset($element[$key]['#field_name'])) && preg_match($pattern, $element[$key]['#field_name'])) {
  
  }
  else {
    $element['#required'] = $required;
  }
  
  /*** conditionally rquired field descriptions
   */
/*
  $rules = nhpid_get_field_conditionally_requireness_fields($node_type);
  $list = array();
  if ($rules){
    foreach($rules as $rule){
      if(in_array($name, array_keys($rule['fields']))){
        $list[] = $rule['label']. ' returns true.';;
      }
    }
    //drupal_set_message(nhpid_api_dump($rules, 'green', TRUE));
    if ($list){
      $element['#description'] = "This field is conditionally required. It follows the following rules: <br>" . theme_item_list($list);
    }
  }*/
  /*** clear cache_content, so that 
   *
   *
   */
  //cache_clear_all('content:', 'cache_content', true);        
  
}

function nhpid_node_form_element_description_alter( $name, &$elements, $node_type) {
  /*** conditionally rquired field descriptions
   */

  $rules = nhpid_get_field_conditionally_requireness_fields($node_type);
  $list = array();
  if ($rule){
    foreach($rules as $rule){
      if(in_array($name, array_keys($rule['fields']))){
        $list[] = $rule['label'] . ' returns true.';
      }
    }
  }
  
  //drupal_set_message(nhpid_api_dump($list, 'green', TRUE));
        
  if ($list){
    
    $des = "This field is conditionally required. It follows the following rules: " . theme_item_list($list);
    $elements['#description'] = $des;
    $field_info = content_fields($name, $noce_type);
    if (!$field_info['multiple']) $elements[0]['value']['#description'] = $des;
  }

}
/**
* Register a node form element for alteration by modules implementing the
* hook_node_form_element_alter() hook.
*/
function nhpid_node_form_element_alter_register(&$elements, $name, $node_type) {
  foreach (element_children($elements) as $key) {
    if (isset($elements[$key]) && ($elements[$key]['#name'] == $name || $elements[$key]['#field_name'] == $name || $elements[$key]['#group_name'] == $name)) {
      foreach (module_implements('node_form_element_alter') as $module) {
        call_user_func_array($module .'_node_form_element_alter', array($name, &$elements[$key],  $node_type));
        call_user_func_array($module .'_node_form_element_description_alter', array($name, &$elements[$key],  $node_type));
      }
    }
    else {
      nhpid_node_form_element_alter_register($elements[$key], $name, $node_type);
    }
  }
}



/**
 * Implementation of hook_nodeapi().
 */

function nhpid_nodeapi(&$node, $op, $a3, $a4) {
  if (!nhpid_is_a_data_node_type($node -> type)) return;
  global $user;
  //try { 
    //drupal_set_message(nhpid_api_dump($node -> title . ": $op", 'red', TRUE));
    //drupal_set_message(nhpid_api_dump($node, 'red', TRUE));
           
    $body_default = "You do not need to input anything. I'll generate a proper text later. If you change it to anything else, I will accept it.";
    $title_default = "I will generate a meaningful title later. Whatever you enter here will be ignored.";
    switch ($op) {  
      case 'alter':
        //drupal_set_message(nhpid_api_dump($node, 'red', TRUE));
        break;
      case 'load':
       
        //*** Add node name to title to let users identify the node type easier. The added node name will not be saved.
        if (nhpid_is_a_data_node_type($node -> type)) {
          $node_name = get_node_name($node -> type);
          $node -> title = $node_name . ': ' . $node -> title;
        }
 
        break;
  
      case 'prepare':
        #### force creating revisiion
        $node -> revision = 1;           
        /***
         * If node is new (no title and body yet), set default title and body
         */                 
        if (!(bool)(trim($node -> title)) and nhpid_is_a_data_node_type($node -> type)) $node -> title = $title_default;
        if (!(bool)(trim(strip_tags($node -> body))) and nhpid_is_a_data_node_type($node -> type)) $node -> body = $body_default;
        /***
         * cache current node for later use, such as set field allowed value php.
         */                 
        //cache_set_nhpid_current_node($node);
        //drupal_set_message(nhpid_api_dump(cache_get_nhpid_current_node(), 'red', TRUE));
        
        ## blocks edting nhpid menu struture nodes by users other than admin
        $nhpid_menu_node_types = array("nhpid_data_entry", "list_records", "nhpid_data_form","nhpid_data_form_group", "fields_house");
        
        if (in_array($node -> type, $nhpid_menu_node_types) and $user -> uid != 1) {
          if (!empty($_SESSION['messages']['status'])) {
            foreach ($_SESSION['messages']['status'] as $key => $message) {
              if (stristr($message, t('This document is now locked against simultaneous editing'))){
                unset ($_SESSION['messages']['status'][$key]);
              }
            } 
            checkout_release($node -> nid, $user -> uid);
          }
          drupal_set_message("You do not have permissions to edit this node nor to add a new node of this type.", 'error');
          drupal_goto(referer_uri());
        }
        
        ## if exporting founction locks the system, prevent to edit or add node
        $exporting_data_locked = variable_get(DATA_EXPORTING_LOCK_VARIABLE, FALSE);
        $exporting_data_temp_locked = variable_get(DATA_EXPORTING_LOCK_TEMP_VARIABLE, FALSE);
        if (($exporting_data_locked and variable_get(DATA_EXPORTING_LOCK_VARIABLE, FALSE) != $user -> uid) or $exporting_data_temp_locked){
          if (!empty($_SESSION['messages']['status'])) {
            foreach ($_SESSION['messages']['status'] as $key => $message) {
              if (stristr($message, t('This document is now locked against simultaneous editing'))){
                unset ($_SESSION['messages']['status'][$key]);
              }
            } 
            checkout_release($node -> nid, $user -> uid);
          }
          drupal_set_message("Data exporting is in progress. The system is locked to prevent data from being changed. Please try it again a few moments later.", 'error');
          drupal_goto(referer_uri());
        }
        
        break;
        
      case 'view':

        break;
  
      case 'delete revision':
        
        break;
      case 'submit':
        
        break;
      
      case 'validate':
        ## skip non-nhpid node types
        $nhpid_types = get_all_nhpid_data_node_types();
        //if (!in_array($node -> type, array_keys($nhpid_types))) return;
        ## get all field names
        $field_names = array_keys(get_node_type_field_name_title_mapping($node->type));
        //drupal_set_message(nhpid_api_dump($field_names, 'red', TRUE));
        ### If data is exporting, lock system to prevent data from changed
        global $user;
        $exporting_data_locked = variable_get(DATA_EXPORTING_LOCK_VARIABLE, FALSE);
        $exporting_data_temp_locked = variable_get(DATA_EXPORTING_LOCK_TEMP_VARIABLE, FALSE);
        if (($exporting_data_locked and variable_get(DATA_EXPORTING_LOCK_VARIABLE, FALSE) != $user -> uid) or $exporting_data_temp_locked){
          form_set_error('', "Data exporting is in progress. The system is locked to prevent data from being changed. Please try it again a few moments later.");
        }
        /***
         * The following validations are added to altered:
         *  1. Node title generation. 
         *      NHPID automattically generates a title (and body) for nodes. For generation title, drupal uses one or two fields of the node.
         *      The title fields and boby field are administered through the admin panel.
         *      If drupal cannot generate a title for a node. An error is evoked.
         *               
         *   2. Unique title, fields and node. 
         *      Drupal checkes if a node tilte is duplicated and unique fields are duplicated for nodes set to unique.
         *      Drupal checkes if a node is totally duplicated (all field except computed fields are duplicated) for all nodes. 
         *      
         *   3. Requiredness.
         *      Drupal re-checkes the requiredness of fields due to the original requiredness validattion function fails to check flexifields.
         *      
         *   4. Length of fields.
         *      Druapl checkes the length of all fields based on settings in the admin panel, which are based on NHPID database tables definstions                                                                                                      
         */                 
        
        /***
         * $errors: holder of all new errors. 
         */                 
        $errors = array();
        /***
         * $required_fields: holder of all required fields of the node. 
         */
        $required_fields = array();
        nhpid_required_fields($a3, $required_fields);

        $type = $node -> type;
        /***
         * Node title generation checking
         */
         $title = nhpid_api_generate_node_title($node);
                       
        if (strlen($title) <= 0  and nhpid_is_a_data_node_type($node -> type)) {
          $title_field1= variable_get('nhpid_' . $node -> type . "_title_field1", '');
          $title_field2= variable_get('nhpid_' . $node -> type . "_title_field2", '');
          $title_field1 = content_fields($title_field1, $type);
          $title_field1_label = $title_field1['widget']['label'];
          
          $title_field_info = "Field $title_field1_label is used for the title. Please make sure it is filled.";
          if ($title_field2) {
            $title_field2 = content_fields($title_field2, $type);
            $title_field2_label = $title_field2['widget']['label'];
            $title_field_info = "Fields  $title_field1_label and $title_field2_label are used for the title. Please make sure they are filled.";
          }
          $errors[] = array('field' => 'title', 'message' => t("Drupal cannot generate title for this node. $title_field_info" ));
        }
        
        /***
         * Unique title and fields checking
         */                 
        if (nhpid_is_a_unique_node_type($type)) {
          $duplicate = db_result(db_query("SELECT nid FROM {node} WHERE type = '%s' AND title = '%s' AND nid <> %d LIMIT 1", $node->type, nhpid_api_generate_node_title($node), $node->nid));
     
          if ($duplicate) {
            //*** since is most likely a duplicate, set an error so a duplicate isn't created
            $errors[] = array('field' => 'title', 'message' => t('A duplicate title is found. This node must hava an unique title. This usually results from clicking the submit button more than once.' ));
          }
          
          //*** unique fields
          
          foreach($field_names as $u_field) {
            if (nhpid_is_a_unique_field($u_field, $type)) {
      
              $field_value_field = $u_field . '_value';
              eval("\$u_field = \"$u_field\";");
              eval("\$field_value_field = \"$field_value_field\";");

              $value = $field[0]['value'];
              if ($value) {
                $sql = sprintf("SELECT node.nid FROM {node}, {content_$u_field} WHERE node.nid = content_$u_field.nid and node.vid = content_$u_field.vid and node.type = '%s' AND content_$u_field.$field_value_field = '%s' AND node.nid != %d LIMIT 1", $node->type, $value, $node->nid);
                $duplicate = db_result(db_query($sql));
                $field = content_fields($u_field, $type);
                $field_label = $field['widget']['label'];
       
                if ($duplicate > 0) {
                  $errors[] = array('field' => $u_field, 'message' => t("A duplicate <em>$field_label</em> is found. This field must be unique. This usually results from clicking the submit button more than once."));
                }
              }
            
            }
          }
        }
       
        
        /***
         * Totally duplication node checking.
         * A totally duplicated field is defined as a node contains duplicated title and all fields (except computed field).
         * Compuated field's value is not assigned untill later stage, so they are should be excluded.                 
         */                 
        $nid = db_result(db_query("SELECT nid FROM {node} WHERE type = '%s' AND title = '%s' AND nid <> %d LIMIT 1", $node->type, nhpid_api_generate_node_title($node), $node->nid));
  
        $duplicated = TRUE;
        
        if ($nid) {
          $existing_node = node_load(array(nid => $nid));
          content_view($existing_node);
          content_view($node);
          //drupal_set_message(nhpid_api_dump($node, 'red', TRUE));
          if (count($existing_node -> content) != count($node -> content)) {
            $duplicated = FALSE;
          }
          else {
            foreach ($existing_node -> content as $key => $value) {
              $field = content_fields($value['field']['#field_name'], $value['field']['#type_name']);
              if ($field['module'] != 'computed_field') {   // computed field's value is calculated at later stage
                
                $$existing_node_value = strip_tags(drupal_render($value));
                $node_value = strip_tags(drupal_render($node -> content[$key]));
                if ($$existing_node_value != $node_value) {
                  $duplicated = FALSE;
                  break;
                  
                }
              }
             }
          }
        }
        else {
          $duplicated = FALSE;
        }
        if ($duplicated) {
          $errors[] = array('field' => '', 'message' => l("A duplicate node is found. ", "node/$nid", array('attributes' => array('target' => '_blank')), NULL, NULL, FALSE, TRUE) . "NHPID does not allow totally duplicated nodes. This usually results from clicking the submit button more than once.");
        }
        /***
         * Field conditionally rquiredness checking
         * The checking is based on nhpid business rule conditionally requiredness
         *
         *                           
         */         
        nhpid_get_field_conditionally_requireness_errors($node, $errors);
        /***
         * Name dependency checking
         * Rule: each common name must be in english synonyms plus english ingredient name 
         *
         *                           
         */ 
         
        $node_types = array('naming_chemical1','naming_chemical1','naming_protein',);
        if (in_array($node -> type, $node_types)){
          nhpid_get_name_fields_dependency_errors($node, $errors);
        }
        
        
        /***
         * Field rquiredness checking
         * NHPID drupal uses dynamic requiredness settings. The requiredness settings of original drupal function are global. This mskes setting required and not required for chared fields in different nodes not possible.
         * The requiredness is re-set through hook_node_field_alter implemented in this module.
         * Since the original rquiredness checking function cannot check fiexifields correctly. Re-checking requiredness must be re-done.
         * Rules:
         *  1.  For required simple fields, the fields must not be empty.
         *  2.  For required compound fields (flexifields), the fields must not be empty and:
         *    for _dependency fields, at least one sub field must not be empty,
         *    for others fields, all sub fields must not be empty.
         *  3. For not required compound fields which are not _dependency fields, all sub fields must be empty or filled.                                                                                
         */  
        //drupal_set_message(nhpid_api_dump($required_fields, 'red', TRUE));               
        $not_empty = array();
        foreach($field_names as $u_field) {
          $value = $node -> $u_field;
          $field = content_fields($u_field, $type);
          //drupal_set_message(nhpid_api_dump($field['module'], 'red', TRUE));
          $field_label = $field['widget']['label'];
          if ($field['module'] != 'computed_field') {
            $empty = $field['module'] .'_content_is_empty';
            $is_empty = $empty($value[0], $field);
            $required = $required_fields[$u_field];
            
            $not_empty[] = $u_field;
            if ($required) {
              //drupal_set_message(nhpid_api_dump($field, 'red', TRUE));
              $pattern = '/field_flexi.+_dependency/';
              if (($field['module'] == 'flexifield') and (preg_match($pattern, $u_field))) {
                nhpid_flexifield_dependency_fields_requiredness_errors($node, $u_field, $field_label, &$errors);
                //drupal_set_message(nhpid_api_dump($u_field, 'red', TRUE));
                //nhpid_get_field_item_requiredness_errors($value, $required_fields, $u_field, $field_label, $errors);
              }
              else {
                nhpid_get_field_item_requiredness_errors($value, $required_fields, $u_field, $field_label, $errors);
              }
              
            }
            elseif ($field['module'] == 'flexifield') {
              $pattern = '/field_flexi.+_dependency/';
              if (!(preg_match($pattern, $u_field))) {
                nhpid_flexifield_one_field_is_empty_errors($value,  $u_field, $field_label, $errors);
              }
            }
            /***
             * Field length checking
             * The max allowed length of nhpid node fields are set through the nhpid admin tool panel
             * If no allowed length for the field found, generates an error.
             * Otherwise, finds any field is too long and generates erors
             * For compound and multi-valued field, the length checking is single-value and singel_item based.
             * The ckecking can be changed to total length based by using function nhpid_get_field_item_length_too_long_errors($value, $u_field, $field_label, $errors, $allowed_len)                                                                          
             */                             
            $variable_name = "nhpid_" . $type . '_' . $u_field . "_length_limit";
            $allowed_len = nhpid_get_nhpid_data_field_allowed_length($type, $u_field);
            //drupal_set_message(nhpid_api_dump("$variable_name: $allowed_len", 'red', TRUE));
            if (empty($allowed_len)) {
              $errors[] = array('field' => $u_field, 'message' => "No allowed max length for <em>$field_label</em> is found in NHPID Rules. Please report the issue to your head.");
            }
            nhpid_get_field_item_length_too_long_errors($value, $u_field, $field_label, $errors, $allowed_len);
            /***
             * Field leading or ending space checking
             * No leading or ending space (use trim() default charset) will be allowed.
             */  
            nhpid_get_field_item_leading_trailing_space_errors($value, $u_field, $field_label, $errors);   
          }

        }
        /***
         *  Reseting form errors
         *  first, copy old errors to a holder
         *  then, delete form errors and error messages,
         *  then, reset old errors which is not a not-empty field.
         *  last, set new errors                                    
         */                 
        
        $old_errors = form_get_errors();
        //drupal_set_message(nhpid_api_dump($old_errors, 'red', TRUE));
        form_set_error(NULL, NULL, TRUE);
        unset($_SESSION['messages']['error']);
        if ($old_errors) {  
          foreach ($old_errors as $error_key => $message) {
            //if (!(in_array($error_key, $not_empty)) and $message == str_replace('field is required.', '', $message )) form_set_error($error_key, $message, FALSE);
            if ($message == str_replace('field is required.', '', $message )) form_set_error($error_key, $message, FALSE);
          }
        }
        foreach ($errors as $error) {
          form_set_error($error['field'], $error['message'], FALSE);
        }
        break;   
        
        case 'presave':
        
        //*** generate title and body if not available
        if (nhpid_is_a_data_node_type($node -> type)) {
          $title = nhpid_api_generate_node_title($node);
          If ((bool)($title)) {
            $node -> title = $title;
          }
          $body =(strip_tags($node -> body));
          If (($body == $body_default) or (!$body)) {
            $node -> body = nhpid_api_generate_node_body($node);
          }
          $node -> teaser = $node -> body;
        }
        
        
        //*** add link url to the field field_its_ids. the url is set in the admin panel
        $its_url = variable_get('nhpid_its_url', '');
        if (property_exists($node, 'field_its_ids')) {
          $index = 0;
          foreach ($node -> field_its_ids as $its_id) {
            if ($its_id['title'] and (!$its_id['url'] or $its_id['url'] == $its_url)) {
              $url = $its_url . str_replace('#', '', $its_id['title']);
              //drupal_set_message(nhpid_api_dump($url, 'red', TRUE));
              $node -> field_its_ids[$index]['url'] = $url;
            }
            $index ++;
          }
        }
        
        ## populate nonnhp_chemical and nonnhp_organism shared fields which nameing lists. Please refer to the function populate_non_nhp_node(&$node).
        //drupal_set_message(nhpid_api_dump($node->type, 'red', TRUE));
        $nonnhp_types = array('nonnhp_chemical', 'nonnhp_organism');
        if (in_array($node -> type, $nonnhp_types))
        {
          #populate_non_nhp_node(&$node); # shared fields should not in non-nhp list
        }
        
        ## change formula file name to the ingredient name of the node
        $chemical_types = array('naming_chemical1', 'naming_chemical2');
        if (in_array($node -> type, $chemical_types))
        {
          //drupal_set_message(nhpid_api_dump($node-> field_formula, 'red', TRUE));
          if (is_array($node -> field_formula[0]) and $node -> field_formula[0]['filename']) {
            $formala_field = $node -> field_formula[0];
            $fid = $formala_field['fid'];
            $old_basename = pathinfo($formala_field['filename'], PATHINFO_FILENAME);
            $ext = pathinfo($formala_field['filename'], PATHINFO_EXTENSION);
            $old_filepath = $formala_field['filepath'];
            $path_parts = pathinfo($old_filepath);
            $dirname = $path_parts['dirname'];
            
            
            $new_basename = $node -> field_ingredient_name[0]['value'];
            $new_filename = "$new_basename.$ext";
            //drupal_set_message(nhpid_api_dump($new_basename, 'brown', TRUE));
            $new_pathname = "$dirname/" .  nhpid_encode_special_filename_characters($new_basename) . ".$ext";
            //drupal_set_message(nhpid_api_dump($new_pathname, 'brown', TRUE));
            if ($formala_field['filepath']) $node  -> field_formula[0]['filepath'] = $new_pathname;
            if ($formala_field['filename']) $node  -> field_formula[0]['filename'] = $new_filename;
            if ($formala_field['destination']) {
              $node  -> field_formula[0]['destination'] = $new_pathname;
            }
           
            //drupal_set_message(nhpid_api_dump($node-> field_formula, 'brown', TRUE));
          
          $sql = "update {files} set filename = '%s', filepath = '%s' where fid = %d";
          if (file_move($old_filepath, $new_pathname)) {
            $result = db_query($sql, $new_filename, $old_filepath, $fid);
            if (!$result) {
                form_set_error('', "Formula uploading failed.");
            }
          }
          }
        }
        
        ### list all duplicates 
        $duplicate_nids = nhpid_fetch_duplicate_node_nids ($node);
        //drupal_set_message(nhpid_api_dump($duplicate_nids, 'red', TRUE));
        $nid_links = array();
        foreach ($duplicate_nids as $nid){
          $nid_links[] = l($nid -> nid . '( ' . $nid -> type . ': ' . $nid -> title . ")",  "node/" . $nid -> nid, array('attributes' => array('target' => '_blank'), 'html' => array('html' => 'TRUE')));
        }
        if ($nid_links) drupal_set_message("There are " . count($nid_links) . " partially duplicate nodes to node you just edited (node type: " . $node -> type . ", node title: " . $node -> title . "). You may want to check/edit them. <br>" . theme_item_list($nid_links), $type = 'status', $repeat = FALSE);

        break;
        
        case 'update':
          //drupal_set_message(nhpid_api_dump($node -> title . ": $op", 'red', TRUE));
          //drupal_set_message(nhpid_api_dump($node, 'red', TRUE));
          //drupal_set_message(nhpid_api_dump($a3, 'red', TRUE));
          //drupal_set_message(nhpid_api_dump($a4, 'red', TRUE));
          /***
           * Field dependency manipulation
           * An NHPID data field can depends on another nhpid field. For exmaple, the field_approved_ingredient_name of node mi_organism dedpends on the field field_ingredient_name of node naming_organism.
           * The dependency rules are set in the admin panel.
           * The function does following:
           *  1. If a depended field is changed, drupal tries to change all depending fields accordingly. If failed, alert user make change manually
           *  2. If an old revison of depended field is restored, drupal tries to change all depending fields accordingly. If failed, alert user make change manually
           *  3. If the workflow state of a depended node is changed from "Published"  to any other state,   Drupal tries to updated the depending node's workflow state accordingly
           *  4. If the workflow state of a depended node is changed form any state to 'Published', Drupal shows warning message to let user change the workflow states of depending nodes if required.
           *  
           * Very tricky code. Please refer to the function variable_set_nhpid_field_dependency in nhpid_api module for depended_field data structure                                                                                           
           */                     
          $depended_fields = array();
          if (nhpid_is_depended_node_type($node -> type)) {
            $depended_fields = nhpid_get_depended_fields($node);
          }
          //drupal_set_message(nhpid_api_dump($depended_fields, 'red', TRUE));
          $links = array();
          $warning_links = array();
         foreach ($depended_fields as $depended_field) {
           //countinue;
           $depended_field_name = $depended_field['depended_field_name'];  
           //$depended_field_value = $depended_field['depended_field_value'];
           $old_depended_node_sid = $depended_field['old_depended_node_workflow_sid'];
           $old_depended_node_workflow_state = get_workflow_state_obj($node -> type, $old_depended_node_sid) -> state;
           $new_depended_node_sid = $depended_field['new_depended_node_workflow_sid'];
           $new_depended_node_workflow_state = get_workflow_state_obj($node -> type, $new_depended_node_sid) -> state;  
            if ($depended_field_name) {
              
              //$closet_revision = nhpid_get_closest_revision_id_by_date($node, $node -> revision_timestamp -1);
              //drupal_set_message(nhpid_api_dump($node, 'blue', TRUE));
              if ($node -> revision){
                ## due to drupal creates duplicate revisions for every update, old_vid is not useful
                $old_vid = nhpid_get_closest_revision_id_by_date($node, $node -> timestap);
                $old_node = node_load($node -> nid, $old_vid);
	              $depended_field_value_array = $old_node ->$depended_field_name;
	              $depended_field_value = $depended_field_value_array[0]['value'];
	              $current_depended_field_value_array = $node ->$depended_field_name;
	              $current_depended_field_value = $current_depended_field_value_array[0]['value'];
							}
              
              //drupal_set_message(nhpid_api_dump("$depended_field_value, $current_depended_field_value, $old_depended_node_sid, $new_depended_node_sid", 'red', TRUE));
               if (  ($depended_field_value and $depended_field_value != $current_depended_field_value) or ($old_depended_node_sid and $old_depended_node_sid != $new_depended_node_sid)) {
                //$depending_nodes = nhpid_get_depending_node_type_fields($depended_field);
                $depending_nodes = nhpid_get_affected_depending_node_type_fields($depended_field, $node);
                //drupal_set_message(nhpid_api_dump($depending_nodes, 'red', TRUE));
                if ($depending_nodes) {
                  foreach ($depending_nodes as $depending_node) {
                    $nid = $depending_node['nid'];
                    $field_name = $depending_node['field_name'];
                    $node_type = $depending_node['node_type'];
                    $updated = $depending_node['updated']? 'Updated successfully.' : 'Updating failed.';
                    $action = $depending_node['updated']? "node/$nid" : "node/$nid/edit";
                    $node_type_name = node_get_types('name', $node_type);
                    $field_info = content_fields($field_name, $node_type);
                    $field_label = $field_info['widget']['label'];
                    $workflow_info = '';
                    if ($depending_node['workflow_state_updated']) $workflow_info = "Workflow: from '<em>" . $depending_node['old_workflow_state'] . "</em>' to '<em>" . $depending_node['new_workflow_state'] . "</em>'<br>";
                    if ($depended_field_value != $current_depended_field_value) $field_value_info = "Field value: from <em>$depended_field_value</em>  to <em>$current_depended_field_value</em>  <br>";
                    //*** If depended field value changed or the workflow state of depened node changed
                    if ($workflow_info or $field_value_info) $links[] = l("Field <em>$field_label ($field_name)</em> of <em>$node_type_name ($node_type)</em> <br>nid: $nid <br> $field_value_info $workflow_info  $updated <br>", $action, array('attributes' => array('target' => '_blank'), 'html' => array('html' => 'TRUE')));
                    
                    // *** if depended node's workflow state is changed to 'Published', reminds user to update the depending nodes
                    //if ($new_depended_node_workflow_state == 'Published' and $old_depended_node_workflow_state != 'Published') {
                    //  $warning_info = "<em>$node_type_name ($node_type)</em> nid: $nid <br>";
                    //  $warning_links[] = l($warning_info, "node/$nid", array('attributes' => array('target' => '_blank'), 'html' => array('html' => 'TRUE')));
                    //}
                  
                  }
                }
              } 
            }                 
         }
         if ($links) drupal_set_message("Data you just edited (node type: " . $node -> type . ", node title: " . $node -> title . ") affects the following fields. I have tried to update them. Please check if the updated nodes are correct and <strong>EDIT</strong> ones not updated successfully manually as soon as possible:<br>" . theme_item_list($links), $type = 'status', $repeat = FALSE);
         //if ($warning_links) drupal_set_message("The workflow state of the node(node type: " . $node -> type . ", node title: " . $node -> title . ") you just edited has been changed from <em>$old_depended_node_workflow_state</em> to <em>$new_depended_node_workflow_state</em>. The following nodes are depending on this node. Please update their workflow states if required. <br> " . theme_item_list($warning_links), $type = 'status', $repeat = FALSE);
        // re-index the node
        nhpid_api_index_node($node);
         ### rebuild_depended_node_relation
        nhpid_build_depended_node_relationship($node);
        break;
        
        case 'insert':
        ### build_depended_node_relation
        nhpid_build_depended_node_relationship($node);
        ### index the node
        //drupal_set_message(nhpid_api_dump("ara: " . arg(0) . '-' .  arg(1) , 'brown', TRUE));
        $arg = arg(0) . '-' .  arg(1);
        if ($arg == 'node-add') nhpid_api_index_node($node); // do index only for manually added node. skip indexing for batch data loading.
        break;
        case 'delete':
        ## delete depended node relationships
        nhpid_delete_depended_node_relationship($node);
        break;
    }
   //}

  //catch (Exception $e) {
  //  form_set_error('Drupal fatal error', t('Cannot complish the operation:' . $e->getMessage() ));
  //}
}

/**
 *  hook theme
 *  
*/  


function nhpid_theme() {
  return array(
    'nhpid_auto_title_form' => array(
      'arguments' => array(
        'form' => array(),
      ),
    ),
    'nhpid_field_dependency_form_summary' => array(
      'arguments' => array(
        'form' => NULL, 
        'saved_dependencies_unserialized' => 'testing',
      ),
    ),
  );
}
/***
 * hook_menu
 */ 
function nhpid_menu() {

  $items = array();
  $root = '';
  $items[$root] = array(
    'title' => 'Assessment Central Rule Management',
    'description' => 'Settings of Assessment Central Rules',
    'menu_name' => 'navigation',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_rule_archive_form'),
    'access arguments' => array('administer assessment central'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'nhpid_forms.inc',
   );
   $items[$root . '/archive'] = array(
    'title' => 'Archive/restore rules',
    'weight' => -11,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_rule_archive_form'),
    //'file' => 'workflow.admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'nhpid_forms.inc',
  );/*
  $items[$root . '/required_fields'] = array(
    'title' => 'Required fields',
    'weight' => -10,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_required_field_form'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'nhpid_forms.inc',
  );
  */
  $items[$root . '/conditionally_required_fields'] = array(
    'title' => 'Conditionally required fields',
    'weight' => -9,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_conditionally_required_field_form'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'nhpid_forms.inc',
  );
  /*
  $items[$root . '/field_dependency'] = array(
    'title' => 'Field dependency',
    'weight' => -9,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_field_dependency_form'),
    'file' => 'nhpid_forms.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items[$root . '/field_dependency_restrictions'] = array(
    'title' => 'Field dependency Restrictions',
    'weight' => -9,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_field_dependency_restrictions_form'),
    'file' => 'nhpid_forms.inc',
    'type' => MENU_LOCAL_TASK,
  );
  */
  $items[$root . '/field_length_limit'] = array(
    'title' => 'Field length limit',
    'weight' => -9,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_field_length_limit_form'),
    'file' => 'nhpid_forms.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items[$root . '/its_url'] = array(
    'title' => 'NHPID ITS link URL',
    'weight' => -8,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_its_url_form'),
    'file' => 'nhpid_forms.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items[$root . '/auto_title_body'] = array(
    'title' => 'Automated node title and body',
    'weight' => -7,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_auto_title_form'),
    'file' => 'nhpid_forms.inc',
    'type' => MENU_LOCAL_TASK,
  );
   $items[$root . '/unique_node_field'] = array(
    'title' => 'Unique node types and fields',
    'weight' => -6,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_unique_node_field_form'),
    'file' => 'nhpid_forms.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items[$root . '/data_node'] = array(
    'title' => 'Assessment Central data node types',
    'weight' => -5,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_data_node_type_form'),
    'file' => 'nhpid_forms.inc',
    'type' => MENU_LOCAL_TASK,
  );
  /*
  $items[$root . '/field_unit_type_mapping'] = array(
    'title' => 'Field Unit type mapping',
    'weight' => -4,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_field_unit_type_mapping_form'),
    'file' => 'nhpid_forms.inc',
    'type' => MENU_LOCAL_TASK,
  );
  
  $items[$root . '/excel_column_title_mapping'] = array(
    'title' => 'Excel column title mapping',
    'weight' => -3,
    'access arguments' => array('administer assessment central'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nhpid_excel_column_title_mapping_form'),
    'file' => 'nhpid_forms.inc',
    'type' => MENU_LOCAL_TASK,
  );
  */
  return $items;
}



function nhpid_validate_conditional_fields($form, &$form_state) {

  $value = trim($form['#value']);
    $new = explode("\n", str_replace("\r", '', $value));
    array_walk($new, 'unique_code_trim');
    $new = array_values(array_filter($new));
    //*** check if every field exist
    $fields_not_exist = "";
    foreach ($new as $field) {
      $sql = "select field_name from {content_node_field} where field_name = '%s'";
      $result = db_query($sql, $field);
      if (!(bool) db_fetch_array($result)) {
        $fields_not_exist = $fields_not_exist . ", $field";
      }
    }
    $fields_not_exist = trim($fields_not_exist, ',');
    if ((bool) $fields_not_exist) {
      form_set_error('nhpid_conditional_fields', t("Fields $fields_not_exist are not found from the NHPID Data Entry"));
    }
    else {
      $form_state['values']['nhpid_conditional_fields'] = implode("\n", $new);
    }
 
}



//*** Helper functions *****

function unique_code_trim(&$item1, $key) {
    $item1 = trim($item1);
}
function nhpid_is_a_unique_node_type($node_type) {
  $unique_node_types = variable_get('nhpid_unique_node_types', array());
  if ($unique_node_types[$node_type]) {
   return TRUE;
  }
  return FALSE;
}
function nhpid_is_unique_node_type($node_type) {
  return nhpid_is_a_unique_node_type($node_type);
}
function nhpid_is_a_unique_node_type_($node_type) {
  $unique_node_types = explode("\n", str_replace("\r", '', variable_get('nhpid_unique_node_type', '')));
  if (in_array($node_type, $unique_node_types)) {
   return TRUE;
  }
  return FALSE;
}
function nhpid_is_a_data_node_type($node_type) {
  $types =  variable_get('nhpid_data_node_types', array());
  if ($types[$node_type]) {
   return TRUE;
  }
  return FALSE;
}

function nhpid_is_a_data_node_type_($node_type) {
  $types =  explode("\n", str_replace("\r", '', variable_get('nhpid_data_node_types', '')));
  if (in_array($node_type, $types)) {
   return TRUE;
  }
  return FALSE;
}
function nhpid_set_data_node_type($node_type) {
  $types = variable_get('nhpid_data_node_types', '');
  
  if (!(in_array($node_type, $types, TRUE))) {
   array_push($types, $node_type);
   variable_set('nhpid_data_node_types',  $types);
  }
}
function nhpid_set_data_node_type_($node_type) {
  $types =  explode("\n", str_replace("\r", '', variable_get('nhpid_data_node_types', '')));
  
  if (!(in_array($node_type, $types, TRUE))) {
   array_push($types, $node_type);
   variable_set('nhpid_data_node_types', implode("\n", $types));
  }
}
function nhpid_is_a_unique_field($field_name, $node_type) {
  $unique_field_id =  "nhpid_$node_type" . '_unique_fields';
  $fields =  variable_get($unique_field_id, array());
  if ($fields[$field_name]) {
   return TRUE;
  }
  return FALSE;
}
function nhpid_is_a_unique_field_($field_name) {
  $fields =  explode("\n", str_replace("\r", '', variable_get('nhpid_unique_nhpid_fields', '')));
  if (in_array($field_name, $fields))  {
   return TRUE;
  }
  return FALSE;
}
function nhpid_is_a_unique_field_in_node_type($field_name, $node_type) {
  if (nhpid_is_a_unique_field($field_name, $node_type) and nhpid_is_a_data_node_type($node_type))  {
   return TRUE;
  }
  return FALSE;
}

function nhpid_is_depended_node_type($node_type) {
  $dependencies = get_nhpid_field_dependencies();
  foreach ($dependencies as $dependency_type => $dependency) {
    if ($dependency['depended_field']['node_type'] == $node_type) {
      return TRUE;
      break;
    }
  }
  return FALSE;
}
function nhpid_get_depended_fields(&$node) {
  $dependencies = get_nhpid_field_dependencies();
  $depended_fields = array();
  foreach ($dependencies as $dependency_type => $dependency) {
    if ($dependency['depended_field']['node_type'] == $node -> type) {
      $depended_field_name = $dependency['depended_field']['field_name'];
      $depending_node_type = $dependency['depending_fields']['node_type'];
      $depending_field_names = $dependency['depending_fields']['field_names'];
      $new_depended_field_value = $node -> $depended_field_name;
      $new_depended_field_value = $new_depended_field_value[0]['value'];
      //if ($node -> nid) $depended_field_value = get_value_of_a_field_by_nid($node->nid, $depended_field_name, $node -> old_vid ? $node -> old_vid: $node -> vid);
      $depended_field_value = get_value_of_a_field_by_nid($node->nid, $depended_field_name);
      //$depended_field_value = get_value_of_a_field_by_nid(2451188, 'field_ingredient_name');
      if ($node -> workflow_stamp){
        $workflow_node_history = get_current_workflow_node_history($node);
        //drupal_set_message(nhpid_api_dump($workflow_node_history , 'purple', TRUE));
        $old_sid = $workflow_node_history -> old_sid;
        //$new_sid  = $workflow_node_history -> sid;
        //$old_sid = $node -> _workflow;
        $new_sid  = $node -> workflow;
      
      }
      
      $depended_fields[] = array('depended_node_type' => $node -> type, 'depended_field_name' => $depended_field_name, 'depended_field_value' => $depended_field_value, 'depending_node_type' => $depending_node_type , 'depending_field_names' => $depending_field_names, 'new_depended_field_value' => $new_depended_field_value, 'old_depended_node_workflow_sid' => $old_sid, 'new_depended_node_workflow_sid' => $new_sid);
    }
  }
  
  return $depended_fields;
}
function nhpid_get_affected_depending_node_type_fields($depended_field, $depended_node) {
  $depended_node_type = $depended_field['depended_node_type'];
  $depending_node_type = $depended_field['depending_node_type'];
  $depending_field_names = $depended_field['depending_field_names'];
  $depended_field_value = $depended_field['depended_field_value'];
  $new_depended_field_value = $depended_field['new_depended_field_value'];
  $old_depended_node_sid = $depended_field['old_depended_node_workflow_sid'];
  $new_depended_node_sid = $depended_field['new_depended_node_workflow_sid'];
  //$old_depended_node_state = get_workflow_state_obj($depended_node_type, $old_depended_node_sid) -> state;
  $old_depended_node_state = workflow_get_state($old_depended_node_sid);
  $old_depended_node_state = $old_depended_node_state['state'];
  $new_depended_node_state = workflow_get_state($new_depended_node_sid);
  $new_depended_node_state = $new_depended_node_state['state'];
  $affected_nodes = array();
  $depending_nodes = nhpid_get_all_depending_nodes($depended_node, null, array($depending_node_type)) ;
  //drupal_set_message(nhpid_api_dump($depended_field , 'blue', TRUE));
  //drupal_set_message(nhpid_api_dump($depending_nodes , 'blue', TRUE));
  //return;
  foreach ($depending_nodes as $depending_node_field){
		
    $updated = FALSE;
    $workflow_state_updated = FALSE;
		//$depended_field_value = $depending_node_field['depended_field_value'];
		$depended_field_name = $depending_node_field['depended_field_name'];
		$depended_workflow_state = workflow_get_state_name(workflow_node_current_state($depended_node));
		$depending_field_name = $depending_node_field['depending_field_name'];
		$depending_node = $depending_node_field['depending_node'];
		$depending_node_changed = $depending_node -> changed;
	//	foreach ($depending_field_names as $depending_field_name) {
			if (!$depending_field_name) continue;
			//drupal_set_message(nhpid_api_dump($depending_node , 'purple', TRUE));
			//drupal_set_message(nhpid_api_dump($depending_field_name , 'blue', TRUE));
			$depending_field_value = $depending_node -> {$depending_field_name}[0]['value'];
		  //if ($new_depended_field_value != $depending_field_value){
		  $index = 0;
		  foreach($depending_node -> {$depending_field_name} as $item){
        //drupal_set_message(nhpid_api_dump($depending_node -> {$depending_field_name} , 'blue', TRUE));
        //drupal_set_message(nhpid_api_dump($depended_field_value , 'blue', TRUE));
        //drupal_set_message(nhpid_api_dump($new_depended_field_value , 'blue', TRUE));
        if (is_array($item) and isset($item['value']) and $item['value'] == $depended_field_value  ){
          $depending_node -> {$depending_field_name}[$index]['value'] = $new_depended_field_value;
          //drupal_set_message(nhpid_api_dump($depending_node -> {$depending_field_name} , 'blue', TRUE));
          break;
        }
        $index ++;
      }
        
        
			//}
			$affected_node_state = workflow_get_state_name(workflow_node_current_state($depending_node ));
			$affected_node_workflow_comment = get_current_workflow_node_history($depending_node) -> comment;
      ## check if workflow state be changed from 'Published' to any other states. If yes, update depending fields accordingly	.
      //drupal_set_message(nhpid_api_dump("$old_depended_node_state, $affected_node_state, $old_depended_node_sid,  $new_depended_node_sid" , 'blue', TRUE));
      if ($old_depended_node_state == 'Published' and $affected_node_state == 'Published' and $new_depended_node_sid != 0 and $old_depended_node_sid != $new_depended_node_sid) {
        //drupal_set_message(nhpid_api_dump("$old_depended_node_state, $affected_node_state, $old_depended_node_sid,  $new_depended_node_sid" , 'red', TRUE));
        workflow_execute_transition($depending_node, $new_depended_node_sid, NHPID_AUTO_WORKFLOW_MSG, true);
        $workflow_state_updated = TRUE;
      }
      if ($new_depended_node_state == 'Published' and $affected_node_state != 'Published' and $old_depended_node_sid != $new_depended_node_sid and $affected_node_workflow_comment == NHPID_AUTO_WORKFLOW_MSG) {
        //drupal_set_message(nhpid_api_dump("$old_depended_node_state, $affected_node_state, $old_depended_node_sid,  $new_depended_node_sid" , 'red', TRUE));
        workflow_execute_transition($depending_node, $new_depended_node_sid, NHPID_AUTO_WORKFLOW_MSG, true);
        $workflow_state_updated = TRUE;
      }
      //drupal_set_message(nhpid_api_dump(NHPID_AUTO_WORKFLOW_MSG , 'blue', TRUE));
      node_save($depending_node);
    
      $affected_node_new_state = get_workflow_state_obj($depending_node -> type, $new_depended_node_sid) -> state;
      ## To confirm that depending node is updated
      if ($depending_node -> changed != $depending_node_changed){
        ### update depended_node relation
        nhpid_build_depended_node_relationship($depending_node, $depending_field_name,$new_depended_field_value, $depended_node -> nid, $depended_field_name);
        //drupal_set_message(nhpid_api_dump($depending_node , 'green', TRUE));
        //drupal_set_message(nhpid_api_dump($depending_field_name , 'green', TRUE));
        $updated = TRUE;
      } 
      $affected_nodes[] = array(nid => $depending_node -> nid, 'field_name' => $depending_field_name, 'node_type' => $depending_node -> type, 'updated' => $updated, 'workflow_state_updated' => $workflow_state_updated, 'new_workflow_state' => $affected_node_new_state, 'old_workflow_state' => $affected_node_state);

		//}
	}

  

  return $affected_nodes;
}
function nhpid_get_depending_node_type_fields($depended_field) {
  
  $depended_node_type = $depended_field['depended_node_type'];
  $depending_node_type = $depended_field['depending_node_type'];
  $depending_field_names = $depended_field['depending_field_names'];
  $depended_field_value = $depended_field['depended_field_value'];
  $new_depended_field_value = $depended_field['new_depended_field_value'];
  $old_depended_node_sid = $depended_field['old_depended_node_workflow_sid'];
  $new_depended_node_sid = $depended_field['new_depended_node_workflow_sid'];
  $old_depended_node_state = get_workflow_state_obj($depended_node_type, $old_depended_node_sid) -> state;
  $affected_nodes = array();

  foreach ($depending_field_names as $depending_field_name) {
    if ($depending_field_name) {
      $workflow_states = workflow_get_states(workflow_get_workflow_for_type($depending_node_type));
      $nids = get_nids_of_a_node_field_by_value($depending_node_type, $depending_field_name, $depended_field_value, NULL, $workflow_states);
      //drupal_set_message(nhpid_api_dump("$depending_node_type, $depending_field_name, $depended_field_value" , 'red', TRUE));
      foreach ($nids as $nid) {
        ## updates affected nodes
        $updated = FALSE;
        $workflow_state_updated = FALSE;
        $affected_node = node_load($nid);
        $affected_field = $affected_node -> $depending_field_name;
        $affected_field[0]['value'] = $new_depended_field_value;
        $affected_node -> $depending_field_name = $affected_field;

        $affected_node_state = workflow_get_state_name(workflow_node_current_state($affected_node));
        ## check if workflow state be changed from 'Published' to any other states. If yes, update depending fields accordingly	.
        //drupal_set_message(nhpid_api_dump("$old_depended_node_state, $affected_node_state, $old_depended_node_sid,  $new_depended_node_sid" , 'blue', TRUE));       
        if ($old_depended_node_state == 'Published' and $affected_node_state == 'Published' and $old_depended_node_sid != $new_depended_node_sid) {
          //drupal_set_message(nhpid_api_dump("$old_depended_node_state, $affected_node_state, $old_depended_node_sid,  $new_depended_node_sid" , 'red', TRUE));
          workflow_execute_transition($affected_node, $new_depended_node_sid, NHPID_AUTO_WORKFLOW_MSG, true);
          $workflow_state_updated = TRUE;
          
        }
        //drupal_set_message(nhpid_api_dump($affected_node , 'blue', TRUE));   
        node_save($affected_node);
        $affected_node = node_load($nid);
        //drupal_set_message(nhpid_api_dump($affected_node , 'green', TRUE));
        $affected_field = $affected_node -> $depending_field_name;
        $affected_node_new_state = get_workflow_state_obj($affected_node -> type, $new_depended_node_sid) -> state;
        if ($affected_field[0]['value'] == $new_depended_field_value) $updated = TRUE;
        $affected_nodes[] = array(nid => $nid, 'field_name' => $depending_field_name, 'node_type' => $depending_node_type, 'updated' => $updated, 'workflow_state_updated' => $workflow_state_updated, 'new_workflow_state' => $affected_node_new_state, 'old_workflow_state' => $affected_node_state); 
      }  
    }
                                                              
  }
 
return $affected_nodes;
}

function nhpid_field_is_empty($field_value_array, $field, $node) {
  $is_empty = TRUE;
  $item1 = $field_value_array[0]['value'];
  
  if ($field['module'] == 'link') {
    if ($field_value_array[0]['url']) $is_empty = FALSE;
  }
  
  elseif (is_array($item1)) {
    foreach ($item1 as $child_name => $child_items) {
      //drupal_set_message(nhpid_api_dump($child_items, 'purple', TRUE));
      if ($child_items[0]['value']) $is_empty = FALSE;
      break;
    }
  }
  else {
    if (content_view_field($field, $node)) $is_empty = FALSE;
  }
  
  return $is_empty;
}

/*** 
 * calculate the lenght of a field based on the format for data exporting
 */ 
function nhpid_field_value_length($node_field, &$length, &$str) {
  
  $count = 0;
  foreach ($node_field as $item) {
    $count ++;
    if (is_array($item['value'])) {
      foreach ($item['value'] as $key => $subfield) {
        if ($key == 'field_code_ref_code' or $key == 'field_mono_citation' or $key == 'field_taxonomical_node') {
          $length = $length + 2;
        }
        nhpid_field_value_length($subfield, $length, $str);
      }
    }
    else {
      if (is_array($item)) {
        $length = $length + strlen($item['value']);
      }
    }
    if ($count > 1 and is_array($item)) {
      $length = $length + 1;
    }
  }
}
function nhpid_get_field_length_too_long_errors($node_field, $field_name, $field_label, &$errors, $length_limit) {
  $length = 0;
  $str = '';
  nhpid_field_value_length($node_field, $length, $str);
  $exceed = $length - $length_limit;
    if ($length_limit > 0 and $exceed > 0) {
      $errors[] = array('field' => $field_name, 'message' => "The value of the field <em>$field_label</em> exceeds allowed lenght ($length_limit) by $exceed.");
    }
        
}

function nhpid_get_field_item_length_too_long_errors($node_field, $field_name, $field_label, &$errors, $length_limit, $error_label = '') {
  $count = 0;
  //if (!$error_name) $error_name = $field_name;
  if (!$error_label) $error_label = $field_label;
  //drupal_set_message(nhpid_api_dump( $field_label, 'purple', TRUE));
  foreach ($node_field as $item) {
    
    if (is_array($item['value'])) {
      foreach ($item['value'] as $key => $subfield) {
        $sub_type = isset($item['type']) ? $item['type']: '';
        if ($sub_type) {
          $sub_field = content_fields($key, $sub_type);
          $sub_field_label = $sub_field['widget']['label'];
          $error_label = $field_label . '(' . strval($count + 1) . ')' . $sub_field_label;
          //drupal_set_message(nhpid_api_dump($sub_field, 'purple', TRUE));
        }
        //$error_name = "$field_name][$count][value][$key";
        
        nhpid_get_field_item_length_too_long_errors($subfield, $field_name, $field_label, $errors, $length_limit, $error_label);
      }
    }
    else {
      if (is_array($item)) {
        $length = strlen($item['value']);
        $exceed = $length - $length_limit;
        if ($length_limit > 0 and $exceed > 0) {
          $error_name = "$error_name][$count][value";
          $error_label = $error_label . '('. strval($count+1) . ')';
          $errors[] = array('field' => $item['_error_element'], 'message' => "The value of the field <em>$error_label ($length letters long) </em> exceeds allowed lenght ($length_limit) by $exceed.");
        }
        
      }
    }
    $count ++;
  }
}

function nhpid_get_field_item_leading_trailing_space_errors($node_field, $field_name, $field_label, &$errors,  $error_label = '') {
  $count = 0;
  //if (!$error_name) $error_name = $field_name;
  if (!$error_label) $error_label = $field_label;
  //drupal_set_message(nhpid_api_dump( $field_label, 'purple', TRUE));
  foreach ($node_field as $item) {
    
    if (is_array($item['value'])) {
      foreach ($item['value'] as $key => $subfield) {
        $sub_type = isset($item['type']) ? $item['type']: '';
        if ($sub_type) {
          $sub_field = content_fields($key, $sub_type);
          $sub_field_label = $sub_field['widget']['label'];
          $error_label = $field_label . '(' . strval($count + 1) . ')' . $sub_field_label;
          //drupal_set_message(nhpid_api_dump($sub_field, 'purple', TRUE));
        }
        //$error_name = "$field_name][$count][value][$key";
        
        nhpid_get_field_item_leading_trailing_space_errors($subfield, $field_name, $field_label, $errors, $error_label);
      }
    }
    else {
      if (is_array($item)) {
        $length = strlen($item['value']);
        $exceed = $length - $length_limit;
        if (strlen($item['value']) !=  strlen(trim($item['value']))) {
          $error_name = "$error_name][$count][value";
          $error_label = $error_label . '('. strval($count+1) . ')';
          $errors[] = array('field' => $item['_error_element'], 'message' => "The value of the field <em>$error_label </em> contains leading or trailing spaces (space, tab, new line, carriage return, NUL-byte, or vertical bar).");
        }
        
      }
    }
    $count ++;
  }
}
function nhpid_flexifield_one_field_is_empty_errors($node_field,  $field_name, $field_label, &$errors) {
  
  $count = 0;
  foreach ($node_field as $item) {

    if (is_array($item['value'])) {
      $empty_count = 0;
      $subitem_count = 0;
      $is_NA = FALSE;
      foreach ($item['value'] as $key => $subfield) {
        $error_name = "$field_name][$count][value][$key][$subitem_count][value";
        $sub_item_value = $subfield[0]['value'];
        if ($sub_item_value == 'NA') $is_NA = TRUE;
        if (strlen(trim($sub_item_value)) == 0 or $sub_item_value == '0') $empty_count ++;
        //drupal_set_message(nhpid_api_dump("$sub_item_value: $is_NA;" , 'blue', TRUE));
      }
      
      if ($empty_count > 0 and $empty_count < count($item['value']) and $is_NA == FALSE) $errors[] = array('field' => $error_name, 'message' => "All fields of <em>$field_label</em> must be filled or set to empty.");
      $subitem_count ++;
    }
    $count ++;
  }
}
function nhpid_flexifield_dependency_fields_requiredness_errors($node, $field_name, $field_label, &$errors) {
  //drupal_set_message(nhpid_api_dump($node_field, 'blue', TRUE));
  $value = compute_computed_dependency_field_value(&$node, $field_name);
  if (empty($value)) $errors[] = array('field' => $field_name, 'message' => "At least one field of <em>$field_label</em> must be filled.");
  
}
function nhpid_get_field_item_requiredness_errors($node_field, &$required_fields, $field_name, $field_label, &$errors, $error_name = '', $error_label = '') {
  $count = 0;
  if (!$error_name) $error_name = $field_name;
  if (!$error_label) $error_label = $field_label;
  //drupal_set_message(nhpid_api_dump( $field_name, 'purple', TRUE));
  foreach ($node_field as $item) {
    
    if (is_array($item['value'])) {
      foreach ($item['value'] as $key => $subfield) {
        $sub_type = isset($item['type']) ? $item['type']: '';
        if ($sub_type) {
          $sub_field = content_fields($key, $sub_type);
          $sub_field_label = $sub_field['widget']['label'];
          $error_label = $field_label . '(' . strval($count + 1) . ')' . $sub_field_label;
          //drupal_set_message(nhpid_api_dump($sub_field_label, 'purple', TRUE));
        }
        $error_name = "$field_name][$count][value][$key";
        
        nhpid_get_field_item_requiredness_errors($subfield, $required_fields, $field_name, $field_label, $errors, $error_name, $error_label);
      }
    }
    else {
      if (is_array($item)) {
        //drupal_set_message(nhpid_api_dump("$error_name: " . $item['value'], 'blue', TRUE));
        //$item_value_key = 'value';
        $item_value = isset($item['value']) ? $item['value'] : $item['url']; // for link fields
        
        if (strlen(trim($item_value)) <= 0 or $item_value == '0') {
          $required_name = strpos($error_name, '[') ? preg_replace('/\]/', '', $error_name, 1) . ']' : $error_name;
          //*** for fields without item index
          $required = $required_fields[$required_name];
          //$error_name1 = "$error_name][value";
          $error_name1 = "$error_name";
          //drupal_set_message(nhpid_api_dump("$error_name1: $required_name: $required " . $item['value'], 'blue', TRUE));
          
          //$error_label = $error_label . '('. strval($count+1) . ')';
          if ($required) $errors[] = array('field' => $error_name1, 'message' => "The field <em>$error_label </em> is required.");
          //*** for fields with item index
          $required_name = $required_name . '[0]';
          $required = $required_fields[$required_name];
          $error_name2 = "$error_name][$count][value";
          //$error_name2 = "$error_name][$count";
          //drupal_set_message(nhpid_api_dump("$error_name2: $required_name: $required " . $item['value'], 'purple', TRUE));
          
          $error_label2 = $error_label . '('. strval($count+1) . ')';
          if ($required) $errors[] = array('field' => $error_name2, 'message' => "The field <em>$error_label2 </em> is required.");
          $required_name = $required_name . '[value]';
          $required = $required_fields[$required_name];
          $error_name3 = "$error_name][$count][value";
          //$error_name2 = "$error_name][$count";
          //drupal_set_message(nhpid_api_dump("$error_name3: $required_name: $required " . $item['value'], 'purple', TRUE));
          
          //$error_label2 = $error_label . '('. strval($count+1) . ')';
          if ($required) $errors[] = array('field' => $error_name3, 'message' => "The field <em>$error_label2 </em> is required.");
          
        }
        
      }
    }
    $count ++;
  }
}
function nhpid_get_field_conditionally_requireness_errors($node, &$errors) {
  
  $rules = nhpid_get_field_conditionally_requireness_fields($node -> type);
  if (!$rules) return;
  foreach($rules as $rule_item){
    $fields = array_keys($rule_item['fields']);
    
    $rule = $rule_item['code'];
    $check_multi_val_flag = $rule_item['check_multi_val_flag'];
    
    ## field values counts
    $counts = array();
    $count_max = 0;
    foreach ($fields as $field){
      $count = count($node -> $field);
      if ($count != 0){
        $counts[$field] = $count;
        if ($count > $count_max) $count_max = $count;
      }
    }
    # if not to check value items
    if ($count_max > 1 and !$check_multi_val_flag) $count_max = 1;
   //drupal_set_message(nhpid_api_dump($count_max, 'blue', TRUE));
    
    //}
    for ($i = 0; $i < $count_max; $i++){
      $all_empty = false;
      /*
      foreach ($fields as $field){
        $item_value = false;
        if (isset($node -> {$field}[$i]['value'])) $item_value = $node -> {$field}[$i]['value'];
        $item_value = (bool)$item_value;
        if (!$item_value) $item_value = 0;
        $code = '$'. $field . ' = ' . $item_value . ';';
        eval($code);
        $all_empty = ($all_empty or $item_value);
        
      }*/
      foreach ($fields as $field){
        $item_value = false;
        $node_tmp = drupal_clone($node);
        content_view($node_tmp);
        //drupal_set_message(nhpid_api_dump($node_tmp -> content, 'blue', TRUE));
        
        //$content_field = content_fields($field, $node_tmp->type);
        if (isset($node_tmp->content[$field]['field']['items'])) {
          $items = $node_tmp->content[$field]['field']['items'];
          
          if ($check_multi_val_flag){
            $output = drupal_render($items[$i]);
          }
          else {
            ## check up by whole field
            $output = drupal_render($items);
          }
          
          //drupal_set_message(nhpid_api_dump("$field: $i: $output", 'blue', TRUE));
          $item_value = (bool)$output;
        }
        
        if (!$item_value) $item_value = 0;
        $code = '$'. $field . ' = ' . $item_value . ';';
        eval($code);
        $all_empty = ($all_empty or $item_value);
        
      }
      //drupal_set_message(nhpid_api_dump($not_empty, 'blue', TRUE));
      if ($all_empty){
        $out = false;
        eval ('$out = (' . $rule. ');'); ### please notice that '()' is required.
        //drupal_set_message(nhpid_api_dump("$rule: $out", 'blue', TRUE));
        $mess = "The fields <em>" . implode(', ', $rule_item['fields']) . ' </em> are conditionally required, meaning either all of them should be empty or the formula <em>' . $rule_item['label'] . '</em> should return true. ';
        $n = $i +1;
        if ($count_max > 1){
          $mess = $mess . "Please check the number $n set of values of the fields.";
        }
        else{
          $mess = $mess . 'Please check the values of all of those fields. ';
        }
        if (!$out){
          $errors[] = array('field' => $rule_item['code'], 'message' => $mess);
        }
      }
    }

  }

}
function nhpid_get_field_conditionally_requireness_fields($node_type) {
  $key = "nhpid_" . $node_type  . "_is_conditionally_required";
  $rules_ori_variable = variable_get($key, '');
  if (!$rules_ori_variable) return null;
  
  $rules_ori = trim($rules_ori_variable, '{}');
  
  $rules_ori = explode('}{', $rules_ori);
  $rules = array();
  //drupal_set_message(nhpid_api_dump($rules_ori, 'blue', TRUE));
  foreach($rules_ori as $rule_ori){
    $rule_out = array();
    $rule_ori_array =  explode('=>', $rule_ori);
    $check_multi_val_flag = $rule_ori_array[1];
    $rule_out['check_multi_val_flag'] = strtoupper($check_multi_val_flag) == 'TRUE' ? TRUE : FALSE;
    $rule_ori = $rule_ori_array[0];
    
    $pattern = '/field_\w*/';
    $matches = array();
    preg_match_all($pattern,$rule_ori,$matches);
    
    $fields = $matches[0];
    /*
    $value = str_replace('{', '', $rule_ori);
    $value = str_replace('}', '', $value);
    $value = str_replace('(', '', $value);
    $value = str_replace(')', '', $value);
    $value = str_replace('|', '&', $value);
    $value = str_replace('^', '&', $value);
    $fields = explode('&', $value);
    */
    $rule = str_replace ('&' , ' AND ', $rule_ori);
    $rule = str_replace ('|' , ' OR ', $rule);
    $rule = str_replace ('^' , ' XOR ', $rule);
    $rule = str_replace ('field_' , '$field_', $rule);
    
    $rule_out['ori'] = $rule_ori;
    $rule_out['code'] = $rule;

    ## field values counts
    $counts = array();
    $count_max = 0;
    $rule_label = $rule;
    $fields_labels = array();
    foreach ($fields as $field){
      $field_info = content_fields($field, $node_type);
      $label = $field_info['widget']['label'];
      //drupal_set_message(nhpid_api_dump("$field: $node_type: $label", 'blue', TRUE));
      $fields_labels[$field] = $label;
      $rule_label = str_replace('$' . $field, $label, $rule_label);
    }
    $rule_out['label'] = $rule_label;
    $rule_out['fields'] = $fields_labels;
    //drupal_set_message(nhpid_api_dump($rule_out, 'blue', TRUE));
    $rules[] = $rule_out;
  }
  return $rules;
}
function nhpid_get_name_fields_dependency_errors($node, &$errors) {
  ## common names
  ## each common name must be one of synonym_e or ingredient_name_e
  //drupal_set_message(nhpid_api_dump($node, 'blue', TRUE));
  $available_names = array();
  $available_names[] = $node -> field_ingredient_name[0]['value'];
  $synonyms_e = $node -> field_flexi_synonym_e;
  
  foreach($synonyms_e as $synonym_e){
    //drupal_set_message(nhpid_api_dump($synonym_e, 'blue', TRUE));
    if (is_array($synonym_e) and isset($synonym_e['value'])) $available_names[] = $synonym_e['value']['field_free_text_part'][0]['value'];
  }
  //drupal_set_message(nhpid_api_dump($available_names, 'blue', TRUE));
  $common_names = $node -> field_flexi_common_name;
  foreach($common_names as $common_name){
   if (is_array($common_name) and isset($common_name['value'])) {
    $name = $common_name['value']['field_free_text_part'][0]['value'];
    //drupal_set_message(nhpid_api_dump($common_name, 'blue', TRUE));
    if (! in_array($name, $available_names)){
      $mess = "Common name<em> $name </em>could not be found in English Synonyms plus NHPID name.";
      $errors[] = array('field' => $common_name['value']['field_free_text_part'][0]['_error_element'], 'message' => $mess);
    }
   }
    
  }
  ## proper names
  ## each proper name must be one of synonym_e or ingredient_name_e
  $proper_names = $node -> field_flexi_proper_name;
  foreach($proper_names as $proper_name){
   if (is_array($proper_name) and isset($proper_name['value'])) {
    $name = $proper_name['value']['field_free_text_part'][0]['value'];
    //drupal_set_message(nhpid_api_dump($proper_name, 'blue', TRUE));
    if (! in_array($name, $available_names)){
      $mess = "Proper name<em> $name </em> could not be found in English Synonyms plus NHPID name.";
      $errors[] = array('field' => $proper_name['value']['field_free_text_part'][0]['_error_element'], 'message' => $mess);
    }
   }
    
  }
}

function nhpid_required_fields($a3, &$required_fields) {
  //drupal_set_message(nhpid_api_dump($a3, 'blue', TRUE));
  foreach ($a3 as $key => $item) {
    if (is_array($item)) {
      if (isset($item['#required'])) {
        if (isset($item['#required'])) {
          
          $field_name = substr($item['#name'], 0, strpos($item['#name'], '['));
          //drupal_set_message(nhpid_api_dump($field_name, 'purple', TRUE));
          $required_fields[$field_name] = $item['#required'];
          $required_fields[$item['#name']] = $item['#required'];
         
        }
      }
      foreach ($item as $item_key => $sub_item) {
        if (is_array($sub_item)) nhpid_required_fields($sub_item, $required_fields);
      }
    } 
    
  }
 //drupal_set_message(nhpid_api_dump($required_fields, 'blue', TRUE));
}

function nhpid_is_nhpid_data_field_required ($node_type, $field_name){
  $variable_name = "nhpid_" . $node_type . '_' . $field_name . "_is_required";
  $required = variable_get($variable_name, 0);
  return $required;
}

function nhpid_get_nhpid_data_field_allowed_length($node_type, $field_name){
  $variable_name = "nhpid_" . $node_type . '_' . $field_name . "_length_limit";
  $allowed_len = variable_get($variable_name, 0);
  return $allowed_len;
}

function _nhpid_node_access_callback($node, $op){
  ## blocks edting nhpid menu struture nodes by users other than admin
  //drupal_set_message(nhpid_api_dump($op, 'blue', TRUE));
  //drupal_set_message(nhpid_api_dump($node, 'blue', TRUE));
  //$node = node_load(array(nid => $nid));
  global $user;
  $nhpid_menu_node_types = array("nhpid_data_entry", "list_records", "nhpid_data_form","nhpid_data_form_group", "fields_house");
  switch($op){
    
    case 'edit':
    if (in_array($node -> type, $nhpid_menu_node_types) and $user -> uid != 1) {
      return false;
    }
    return node_access('update', $node);
    break;
    
    case 'revisions':
  
    if (in_array($node -> type, $nhpid_menu_node_types) and $user -> uid != 1) {
      return false;
    }
    return  diff_node_revision_access($node);
    break;
    
    case 'children':
    if ($user -> uid != 1){
      return false;
    }
    return true;
    break;
  }
  
}